<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Frontier DOOH - MapLibre Ready Test</title>

  <!-- MapLibre (확정 버전) -->
  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" />
  <style>
    html, body { height: 100%; margin: 0; background:#0b0c0d; color:#e8eaed; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", sans-serif; }
    .topbar { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,.12); display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .badge { padding: 4px 8px; border: 1px solid rgba(255,255,255,.18); border-radius: 999px; font-size: 12px; background: rgba(255,255,255,.06); }
    .k { color:#a2decc; }
    #map { height: calc(100% - 56px); }
    a { color:#a2decc; text-decoration:none; }
    .muted { color: rgba(232,234,237,.7); }
  </style>
</head>
<body>
  <div class="topbar">
    <span class="badge"><span class="k">MapLibre</span> 3.6.1</span>
    <span class="badge"><span class="k">Style</span> dataviz-v4-dark</span>
    <span class="badge"><span class="k">DATA</span> <span id="dataUrl"></span></span>
    <span class="badge"><span class="k">Status</span>: <span id="status">Loading…</span></span>
    <span class="badge"><span class="k">Sanitize</span>: <span id="sanitize">-</span></span>
    <span class="muted">옵션: <span class="k">?data=dummy5000</span> 로 더미(5천) 테스트</span>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script>
  (function(){
    "use strict";

    // ============================================================
    // [이식용 블록] MapLibre + 한글라벨 + 클러스터 + sanitize + 순서고정
    // ============================================================

    const STYLE_URL = "https://demotiles.maplibre.org/style.json";


    // data 선택: 기본은 운영과 동일 경로(현재는 샘플 20개), 더미는 ?data=dummy5000
    const params = new URLSearchParams(location.search);
    const DATA_URL = (params.get("data") === "dummy5000")
      ? "./data_public_dummy_5000.json"
      : "./data_public.json";

    document.getElementById("dataUrl").textContent = DATA_URL;

    function sanitizePoints(list){
      const stats = {
        total: Array.isArray(list) ? list.length : 0,
        nan: 0,
        outLat: 0,
        outLng: 0,
        korOut: 0,
        kept: 0
      };

      const pts = [];
      const arr = Array.isArray(list) ? list : [];

      for (let i = 0; i < arr.length; i++){
        const x = arr[i] || {};

        const lat = (typeof x.lat === "number")
          ? x.lat
          : parseFloat(String(x.lat ?? "").trim());

        const lng = (typeof x.lng === "number")
          ? x.lng
          : parseFloat(String(x.lng ?? "").trim());

        // 1) 숫자 변환 실패
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) { stats.nan++; continue; }

        // 2) 지구 좌표 범위 이탈(크래시 유발 방지)
        if (lat < -90 || lat > 90) { stats.outLat++; continue; }
        if (lng < -180 || lng > 180) { stats.outLng++; continue; }

        // 3) 국내 범위(현 정책 유지)
        if (lat < 32.0 || lat > 39.8 || lng < 123.0 || lng > 132.5) { stats.korOut++; continue; }

        stats.kept++;
        pts.push({ ...x, lat, lng });
      }

      return { pts, stats };
    }

    function toGeoJSON(points){
      return {
        type: "FeatureCollection",
        features: points.map(p => ({
          type: "Feature",
          geometry: { type: "Point", coordinates: [p.lng, p.lat] },
          properties: { ...p }
        }))
      };
    }

    function applyKoreanLabels(map){
      // "name:ko" 우선, 없으면 name
      const style = map.getStyle && map.getStyle();
      if (!style || !style.layers) return;

      for (const layer of style.layers){
        if (!layer || layer.type !== "symbol") continue;
        const tf = layer.layout && layer.layout["text-field"];
        if (!tf) continue;

        try {
          map.setLayoutProperty(layer.id, "text-field", ["coalesce", ["get","name:ko"], ["get","name"]]);
        } catch (e) {
          // 일부 레이어는 수정 불가일 수 있음(무시)
        }
      }
    }

    function addClusterLayers(map){
      // cluster 원/숫자/단일 포인트 레이어
      map.addLayer({
        id: "clusters",
        type: "circle",
        source: "points",
        filter: ["has", "point_count"],
        paint: {
          "circle-radius": [
            "step", ["get", "point_count"],
            16, 50, 22, 200, 28, 1000, 34
          ],
          "circle-stroke-width": 1,
          "circle-stroke-color": "rgba(255,255,255,0.25)",
          "circle-color": "rgba(162,222,204,0.28)"
        }
      });

      map.addLayer({
        id: "cluster-count",
        type: "symbol",
        source: "points",
        filter: ["has", "point_count"],
        layout: {
          "text-field": "{point_count_abbreviated}",
          "text-size": 12
        },
        paint: {
          "text-color": "rgba(232,234,237,0.95)"
        }
      });

      map.addLayer({
        id: "unclustered-point",
        type: "circle",
        source: "points",
        filter: ["!", ["has", "point_count"]],
        paint: {
          "circle-radius": 6,
          "circle-stroke-width": 1,
          "circle-stroke-color": "rgba(255,255,255,0.35)",
          "circle-color": "rgba(162,222,204,0.75)"
        }
      });

      // 클릭 UX: “과격한 확대” 완화
      const MAX_ZOOM_CAP = 16;     // 너무 깊게 못 들어가게 상한
      const MAX_ZOOM_STEP = 2;     // 현재 줌에서 최대 +2까지만
      const EASE_MS = 650;

      map.on("click", "clusters", (e) => {
        const features = map.queryRenderedFeatures(e.point, { layers: ["clusters"] });
        if (!features || !features.length) return;

        const f = features[0];
        const clusterId = f.properties.cluster_id;
        const source = map.getSource("points");

        source.getClusterExpansionZoom(clusterId, (err, expansionZoom) => {
          if (err) return;

          const current = map.getZoom();
          const targetZoom = Math.min(expansionZoom, current + MAX_ZOOM_STEP, MAX_ZOOM_CAP);

          map.easeTo({
            center: f.geometry.coordinates,
            zoom: targetZoom,
            duration: EASE_MS
          });
        });
      });

      map.on("click", "unclustered-point", (e) => {
        const f = e.features && e.features[0];
        if (!f) return;

        const p = f.properties || {};
        const name = p.name || p.title || p.site || "매체";
        const addr = p.address || p.addr || "";
        const html = `
          <div style="min-width:220px">
            <div style="font-weight:700;margin-bottom:6px">${escapeHtml(name)}</div>
            ${addr ? `<div style="opacity:.8;font-size:12px">${escapeHtml(addr)}</div>` : ""}
          </div>
        `;

        new maplibregl.Popup({ closeButton: true, closeOnClick: true })
          .setLngLat(f.geometry.coordinates)
          .setHTML(html)
          .addTo(map);
      });

      map.on("mouseenter", "clusters", () => map.getCanvas().style.cursor = "pointer");
      map.on("mouseleave", "clusters", () => map.getCanvas().style.cursor = "");
      map.on("mouseenter", "unclustered-point", () => map.getCanvas().style.cursor = "pointer");
      map.on("mouseleave", "unclustered-point", () => map.getCanvas().style.cursor = "");
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (m) => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[m]));
    }

    async function loadData(url){
      const r = await fetch(url, { cache: "no-store" });
      if (!r.ok) throw new Error("HTTP " + r.status + " (" + url + ")");
      const json = await r.json();
      // data_public.json 구조: {meta, items:[...]} 또는 배열
      return Array.isArray(json) ? json : (Array.isArray(json.items) ? json.items : []);
    }

    async function main(){
      const statusEl = document.getElementById("status");
      const sanitizeEl = document.getElementById("sanitize");

      statusEl.textContent = "Style loading…";

      let raw;
      try {
        raw = await loadData(DATA_URL);
      } catch (e) {
        statusEl.textContent = "ERROR: data load failed";
        console.error(e);
        return;
      }

      const { pts, stats } = sanitizePoints(raw);
      sanitizeEl.textContent = `total:${stats.total} kept:${stats.kept} nan:${stats.nan} outLat:${stats.outLat} outLng:${stats.outLng} korOut:${stats.korOut}`;
      console.log("[DATA_SANITIZE]", stats);

      const geojson = toGeoJSON(pts);

      const map = new maplibregl.Map({
        container: "map",
        style: STYLE_URL,
        center: [127.0, 37.5],
        zoom: 6,
        attributionControl: true
      });
// ★ 스타일/타일 로딩 에러를 화면에 표시 (DevTools 없이 원인 확정용)
map.on("error", (e) => {
  try {
    const msg =
      (e && e.error && (e.error.message || e.error.status || e.error.code)) ?
        (e.error.message || ("status=" + e.error.status) || ("code=" + e.error.code)) :
      (e && e.sourceId) ? ("source=" + e.sourceId) :
      "unknown error";
    statusEl.textContent = "ERROR: " + msg;
  } catch (_) {
    statusEl.textContent = "ERROR: map error";
  }
});

      map.addControl(new maplibregl.NavigationControl({ showZoom: true, showCompass: false }), "top-right");

      // 레이스 방지: load 이후에만 source/layer 추가
      map.on("load", () => {
        try {
          // 한글 라벨 패치(요구사항)
          applyKoreanLabels(map);

          map.addSource("points", {
            type: "geojson",
            data: geojson,
            cluster: true,
            clusterRadius: 50,
            clusterMaxZoom: 14
          });

          addClusterLayers(map);

          statusEl.textContent = "Loaded OK";
        } catch (e) {
          statusEl.textContent = "ERROR: init failed";
          console.error(e);
        }
      });

      // 일부 스타일에서 load 이후 텍스트가 다시 바뀌는 경우 보강(1회성 가드)
      let koApplied = false;
      map.on("styledata", () => {
        if (koApplied) return;
        // load 이후 첫 styledata 때 한번만 적용
        if (map.isStyleLoaded && map.isStyleLoaded()){
          koApplied = true;
          try { applyKoreanLabels(map); } catch(e){}
        }
      });
    }

    main();
  })();
  </script>
</body>
</html>
